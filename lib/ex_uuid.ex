defmodule ExUUID do
  @moduledoc """
  UUID generator according to [RFC 4122](https://www.ietf.org/rfc/rfc4122.txt).
  """

  import ExUUID.Impl,
    only: [
      uuid: 3,
      uuid: 5,
      timestamp: 0,
      clock_sequence: 0,
      node_id: 0,
      random_node_id: 1,
      hash: 3
    ]

  alias ExUUID.Impl

  @type bin :: <<_::128>>

  @type str :: <<_::288>>

  @type hex :: <<_::256>>

  @type uuid :: bin() | str() | hex()

  @type namespace :: :dns | :url | :oid | :x500 | nil | uuid

  @type name :: binary()

  @type version :: 1 | 3 | 4 | 5 | 6

  @type variant ::
          :rfc4122
          | :reserved_future
          | :reserved_microsoft
          | :reserved_ncs

  @type format :: :default | :hex | :binary

  @namespaces [:dns, :url, :oid, :x500, nil]

  @doc """
  Builds a new UUID of the given `version` and `format`.

  - Version `:v1` returns a UUID generated by a timestamp and node id.
  - Version `:v4` return a UUID generated by a (pseudo) random number generator.
  - Version `:v6` returns a UUID generated by a timestamp and node id. With the
    option `random: true` the node is generated by a (pseudo) random number
    generator. The default is `true`.

  The option `:format` specifies the type of the UUID, possible values are
  `:default`, `:hex`, and `binary`. The default is `:default`.

  ## Examples
  ```elixir
  iex> ExUUID.new(:v1)
  "58044c1e-51e1-11eb-b72d-0982c5a64d6d"

  iex> ExUUID.new(:v1, format: :hex)
  "58044c1e51e111ebb72d0982c5a64d6d"

  iex> ExUUID.new(:v1, fromat: :binary)
  <<88, 4, 76, 30, 81, 225, 17, 235, 183, 45, 9, 130, 197, 166, 77, 109>>

  iex> ExUUID.new(:v4)
  "be134339-2dba-465b-9961-1ac281f111d8"

  iex> ExUUID.new(:v6)
  "1eb51e21-bd8e-606e-a438-33b3c732d898"

  iex> ExUUID.new(:v6, random: false)
  "1eb51e23-1704-66ce-a6ef-0982c5a64d6d"
  ```
  """
  @spec new(:v1 | :v4 | :v6, keyword()) :: uuid()
  def new(version, opts \\ [])

  def new(:v1, opts) do
    uuid(:v1, timestamp(), clock_sequence(), node_id(), format(opts))
  end

  def new(:v4, opts) do
    uuid(:v4, :crypto.strong_rand_bytes(16), format(opts))
  end

  def new(:v6, opts) do
    node_id = random_node_id(Keyword.get(opts, :random, true))
    uuid(:v6, timestamp(), clock_sequence(), node_id, format(opts))
  end

  @doc """
  Builds a new UUID of the given `version` and `format`.

  - Version `:v3` returns a UUID generated using MD5 and a given `name` within a
    `namespace`.
  - Version `:v5` returns a UUID generated using SHA1 and a given `name`
    within a `namespace`.

  The option `:format` specifies the type of the UUID, possible values are
  `:default`, `:hex`, and `binary`. The default is `:default`.

  ## Examples
  ```elixir
  iex> ExUUID.new(:v3, :dns, "example.com")
  "9073926b-929f-31c2-abc9-fad77ae3e8eb"

  iex> ExUUID.new(:v5, :dns, "example.com", format: :hex)
  "cfbff0d193755685968c48ce8b15ae17"

  iex> ExUUID.new(:v5, :dns, "example.com", format: :binary)
  <<207, 191, 240, 209, 147, 117, 86, 133, 150, 140, 72, 206, 139, 21, 174, 23>>

  iex> ns = "58044c1e-51e1-11eb-b72d-0982c5a64d6d"
  ...> ExUUID.new(:v3, ns, "example.com")
  "c2e032d5-369d-39f3-a274-a7cf0f556202"
  iex> {:ok, ns_bin} = ExUUID.to_binary(ns)
  iex> ExUUID.new(:v3, ns_bin, "example.com")
  "c2e032d5-369d-39f3-a274-a7cf0f556202"
  ```
  """
  @spec new(:v3 | :v5, namespace(), name(), keyword()) :: uuid()
  def new(version, namespace, name, opts \\ [])
      when (namespace in @namespaces or is_binary(namespace)) and
             version in [:v3, :v5] and
             is_binary(name) do
    case hash(version, namespace, name) do
      {:ok, hash} -> uuid(version, hash, format(opts))
      :error -> raise ArgumentError, "invalid namespace"
    end
  end

  @doc """
  Converts the `uuid` to binary.

  Returns `{:ok, binary}` for a valid UUID, otherwise `error`.

  ## Examples
  ```elixir
  iex> ExUUID.to_binary("58044c1e-51e1-11eb-b72d-0982c5a64d6d")
  {:ok, <<88, 4, 76, 30, 81, 225, 17, 235, 183, 45, 9, 130, 197, 166, 77, 109>>}
  iex> ExUUID.to_binary("58044c1e-xxxx-11eb-b72d-0982c5a64d6d")
  :error
  ```
  """
  @spec to_binary(uuid()) :: {:ok, bin()} | :error
  def to_binary(uuid), do: Impl.to_binary(uuid)

  @doc """
  Converts the binary `uuid` to a string in the given `:format` option.

  Returns `{:ok, string}` for a valid UUID, otherwise `error`.

  ## Examples
  ```elixir
  iex> ExUUID.to_string(
  ...>   <<88, 4, 76, 30, 81, 225, 17, 235, 183, 45, 9, 130, 197, 166, 77, 109>>)
  {:ok, "58044c1e-51e1-11eb-b72d-0982c5a64d6d"}

  iex> ExUUID.to_string(
  ...>   <<88, 4, 76, 30, 81, 225, 17, 235, 183, 45, 9, 130, 197, 166, 77, 109>>,
  ...>   format: :hex)
  {:ok, "58044c1e51e111ebb72d0982c5a64d6d"}
  ```
  """
  @spec to_string(uuid(), keyword()) :: {:ok, uuid()} | :error
  def to_string(uuid, opts \\ []), do: Impl.to_string(uuid, format(opts))

  @doc """
  Returns `true` if the given `uuid` is valid, otherwise `false`.

  ## Examples
  ```elixir
  iex> ExUUID.valid?("58044c1e-51e1-11eb-b72d-0982c5a64d6d")
  true

  iex> ExUUID.valid?("58044c1e-51e1-ffff-b72d-0982c5a64d6d")
  false
  ```
  """
  @spec valid?(uuid()) :: boolean()
  def valid?(uuid), do: Impl.valid?(uuid)

  @doc """
  Returns the variant for the given `uuid`.

  Returns `{:ok, variant}` for a valid UUID, otherwise `:error`.

  ## Examples
  ```elixir
  iex> ExUUID.variant("58044c1e51e111ebb72d0982c5a64d6d")
  {:ok, :rfc4122}
  ```
  """
  @spec variant(uuid()) :: {:ok, variant()} | :error
  def variant(uuid), do: Impl.variant(uuid)

  @doc """
  Returns the version for the given `uuid`.

  Returns `{:ok, version}` for a valid UUID, otherwise `:error`.

  ## Examples
  ```elixir
  iex> :v1 |> ExUUID.new() |> ExUUID.version()
  {:ok, 1}
  ```
  """
  @spec version(uuid()) :: {:ok, version()} | :error
  def version(uuid), do: Impl.version(uuid)

  defp format(opts), do: Keyword.get(opts, :format, :default)
end
